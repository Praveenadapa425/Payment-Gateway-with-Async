previous project info 


Partnr Logo
Dashboard
Skill Graph
Profile
GPP

Praveen Adapa
Build Payment Gateway with Multi-Method Processing and Hosted Checkout
Mandatory Task

Back
Domain
Backend Development
Skills
API Authentication
API Development
Artificial Intelligence
Database Management
Deep Learning
Frontend Development
Full-Stack Development
Payment Gateway Development
Payment Validation Logic
Public Relations
State Machine Implementation
Difficulty
Hard
Tools
Docker
Express.Js
FastAPI
Java
Node.Js
PostgreSQL
Postman
Python
React
Spring Boot
Vue.Js
Industries
E-commerce
Fintech
Submission Received
Your submission has been received and is pending review. You can still update your submission till the effective deadline.

Submitted on 10 Jan 2026, 02:16 pm

Deadline: 10 Jan 2026, 04:59 pm

Overview
Instructions
Resources
Submit
Description
Objective
In this project, you will build the foundational components of a payment gateway similar to Razorpay or Stripe. This is a significant step up from basic CRUD applications as you'll implement merchant onboarding, payment order management, multi-method payment processing (UPI and Cards), and a hosted checkout page.

You'll gain hands-on experience with API authentication patterns, payment validation logic, state machines for transaction lifecycle management, and building user-facing payment interfaces. By the end of this deliverable, you'll have a functional payment gateway where merchants can create payment orders via API, and customers can complete payments through a hosted checkout page. This project will demonstrate your ability to build financial technology systems and handle sensitive transaction flows—skills highly valued in the fintech and e-commerce industries.

Core Requirements
Dockerized deployment with all services (API, database, frontend) running via docker-compose up -d in a single command
RESTful API with fixed endpoints for creating orders, processing payments, and querying transaction status
Merchant authentication using API key and secret for all protected endpoints
Payment processing for both UPI (with VPA validation) and Card payments (with Luhn algorithm validation and network detection)
Hosted checkout page where customers are redirected to complete their payment with a professional UI
Database persistence with proper schema for merchants, orders, and payments with correct relationships
Implementation Details
Project Structure
While you can use any technology stack, here's a recommended structure using Java Spring Boot as reference:

payment-gateway/
├── docker-compose.yml
├── README.md
├── .env.example
├── backend/
│   ├── Dockerfile
│   ├── pom.xml / build.gradle
│   ├── src/
│   │   └── main/
│   │       ├── java/com/gateway/
│   │       │   ├── PaymentGatewayApplication.java
│   │       │   ├── config/
│   │       │   │   └── SecurityConfig.java
│   │       │   ├── controllers/
│   │       │   │   ├── HealthController.java
│   │       │   │   ├── OrderController.java
│   │       │   │   └── PaymentController.java
│   │       │   ├── models/
│   │       │   │   ├── Merchant.java
│   │       │   │   ├── Order.java
│   │       │   │   └── Payment.java
│   │       │   ├── repositories/
│   │       │   ├── services/
│   │       │   │   ├── OrderService.java
│   │       │   │   ├── PaymentService.java
│   │       │   │   └── ValidationService.java
│   │       │   └── dto/
│   │       └── resources/
│   │           ├── application.properties
│   │           └── schema.sql
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   ├── src/
│   │   ├── pages/
│   │   │   ├── Login.jsx
│   │   │   ├── Dashboard.jsx
│   │   │   └── Transactions.jsx
│   │   └── components/
└── checkout-page/
    ├── Dockerfile
    ├── src/
    │   ├── pages/
    │   │   ├── Checkout.jsx
    │   │   ├── Success.jsx
    │   │   └── Failure.jsx
    │   └── components/
Docker Compose Configuration
Your docker-compose.yml must define these exact service names and ports:

version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: pg_gateway
    environment:
      POSTGRES_DB: payment_gateway
      POSTGRES_USER: gateway_user
      POSTGRES_PASSWORD: gateway_pass
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U gateway_user -d payment_gateway"]
      interval: 10s
      timeout: 5s
      retries: 5

  api:
    build:
      context: ./backend
    container_name: gateway_api
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql://gateway_user:gateway_pass@postgres:5432/payment_gateway
      PORT: 8000
    depends_on:
      postgres:
        condition: service_healthy

  dashboard:
    build:
      context: ./frontend
    container_name: gateway_dashboard
    ports:
      - "3000:80"
    depends_on:
      - api

  checkout:
    build:
      context: ./checkout-page
    container_name: gateway_checkout
    ports:
      - "3001:80"
    depends_on:
      - api
Database Schema
Your database must implement the following schema with these exact table structures, field names, data types, and relationships:

Merchants Table:

id: Unique identifier (UUID format), primary key, auto-generated
name: Merchant name (string, up to 255 characters), required
email: Email address (string, up to 255 characters), required, must be unique
api_key: API key for authentication (string, up to 64 characters), required, must be unique
api_secret: API secret for authentication (string, up to 64 characters), required
webhook_url: Webhook URL for event notifications (text, optional)
is_active: Active status flag (boolean), defaults to true
created_at: Creation timestamp, auto-set to current time
updated_at: Last update timestamp, auto-set to current time
Orders Table:

id: Order identifier (string, up to 64 characters), primary key, format: "order_" + 16 alphanumeric characters
merchant_id: Reference to merchants table (UUID), required, foreign key to merchants(id)
amount: Order amount in smallest currency unit (integer), required (minimum 100)
currency: Currency code (string, 3 characters), defaults to 'INR'
receipt: Receipt identifier (string, up to 255 characters), optional
notes: Additional notes/metadata (JSON object), optional
status: Order status (string, up to 20 characters), defaults to 'created'
created_at: Creation timestamp, auto-set to current time
updated_at: Last update timestamp, auto-set to current time
Payments Table:

id: Payment identifier (string, up to 64 characters), primary key, format: "pay_" + 16 alphanumeric characters
order_id: Reference to orders table (string, up to 64 characters), required, foreign key to orders(id)
merchant_id: Reference to merchants table (UUID), required, foreign key to merchants(id)
amount: Payment amount in smallest currency unit (integer), required
currency: Currency code (string, 3 characters), defaults to 'INR'
method: Payment method (string, up to 20 characters), required (values: "upi" or "card")
status: Payment status (string, up to 20 characters), defaults to 'created' (but should be set to 'processing' immediately upon creation)
vpa: Virtual Payment Address for UPI payments (string, up to 255 characters), optional, only for UPI method
card_network: Card network identifier (string, up to 20 characters), optional, only for card method (values: "visa", "mastercard", "amex", "rupay", "unknown")
card_last4: Last 4 digits of card number (string, 4 characters), optional, only for card method
error_code: Error code if payment fails (string, up to 50 characters), optional
error_description: Error description if payment fails (text), optional
created_at: Creation timestamp, auto-set to current time
updated_at: Last update timestamp, auto-set to current time
Required Indexes:

Index on orders.merchant_id for efficient merchant order queries
Index on payments.order_id for efficient order payment queries
Index on payments.status for efficient status-based queries
Database seeding requirement: Your application must automatically create a test merchant on startup with these exact credentials:

id: 550e8400-e29b-41d4-a716-446655440000
name: Test Merchant
email: test@example.com
api_key: key_test_abc123
api_secret: secret_test_xyz789
created_at: Current timestamp at startup
If a merchant with this email already exists, skip the insertion (handle duplicate gracefully). This test merchant must be available immediately after application startup for testing purposes.

API Specification
All endpoints must be implemented exactly as specified below:

Base URL: http://localhost:8000

1. Health Check Endpoint
GET /health

Response 200:
{
  "status": "healthy",
  "database": "connected",
  "timestamp": "2024-01-15T10:30:00Z"
}
Implementation requirements:

Create an endpoint handler for GET /health that does not require authentication
Verify database connectivity by attempting a simple database query
Check if the application is ready to serve requests
Return a JSON response with the following structure:
status: String value "healthy"
database: String value "connected" (or "disconnected" if database check fails)
timestamp: ISO 8601 formatted timestamp string (e.g., "2024-01-15T10:30:00Z")
Return HTTP status code 200 on success
Enhanced Health Check for Deliverable 2 (Required): For Deliverable 2, the health check endpoint should also include Redis and worker status:

{
  "status": "healthy",
  "database": "connected",
  "redis": "connected",
  "worker": "running",
  "timestamp": "2024-01-15T10:30:00Z"
}
redis: String value "connected" (or "disconnected" if Redis check fails)
worker: String value "running" (or "stopped" if worker is not processing jobs)
This allows evaluators to verify all required services are operational in a single request.

2. Create Order Endpoint
POST /api/v1/orders

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789
Content-Type: application/json

Request Body:
{
  "amount": 50000,
  "currency": "INR",
  "receipt": "receipt_123",
  "notes": {
    "customer_name": "John Doe"
  }
}

Response 201:
{
  "id": "order_NXhj67fGH2jk9mPq",
  "merchant_id": "550e8400-e29b-41d4-a716-446655440000",
  "amount": 50000,
  "currency": "INR",
  "receipt": "receipt_123",
  "notes": {
    "customer_name": "John Doe"
  },
  "status": "created",
  "created_at": "2024-01-15T10:30:00Z"
}

Error Response 400:
{
  "error": {
    "code": "BAD_REQUEST_ERROR",
    "description": "amount must be at least 100"
  }
}

Error Response 401:
{
  "error": {
    "code": "AUTHENTICATION_ERROR",
    "description": "Invalid API credentials"
  }
}
Error Response Standardization (Required for Evaluation): All error responses must use these exact error codes:

AUTHENTICATION_ERROR - Invalid API credentials
BAD_REQUEST_ERROR - Validation errors
NOT_FOUND_ERROR - Resource not found
PAYMENT_FAILED - Payment processing failed (if used)
INVALID_VPA - VPA format invalid (if used)
INVALID_CARD - Card validation failed (if used)
EXPIRED_CARD - Card expiry date invalid (if used)
INSUFFICIENT_REFUND_AMOUNT - Refund amount exceeds available (Deliverable 2)
Error descriptions should be clear and match the examples provided. Exact error code matching is required for automated evaluation.

Implementation requirements:

Create an endpoint handler for POST /api/v1/orders that requires authentication
Extract and validate API credentials from request headers:
X-Api-Key: Must match an existing merchant's api_key in the database
X-Api-Secret: Must match the corresponding api_secret for that merchant
If credentials are invalid, return 401 with error code "AUTHENTICATION_ERROR"
Validate request body:
amount: Must be an integer >= 100 (minimum amount is 100 paise = ₹1.00)
Note: Amounts are stored in paise (smallest currency unit)
Example: ₹500.00 = 50000 paise
currency: Optional, defaults to "INR" if not provided
receipt: Optional string identifier
notes: Optional JSON object for additional metadata
If validation fails, return 400 with error code "BAD_REQUEST_ERROR"
Generate order ID:
Format: "order_" followed by exactly 16 alphanumeric characters
Must be unique (check for collisions and regenerate if needed)
Create order record in database:
Set status to "created"
Associate with the authenticated merchant
Store all provided fields
Set timestamps (created_at, updated_at)
Return response:
HTTP status code 201
JSON body containing all order fields including generated id, merchant_id, status, and timestamps
Order ID generation: Must follow format order_ followed by exactly 16 alphanumeric characters (e.g., order_NXhj67fGH2jk9mPq)

3. Get Order Endpoint
GET /api/v1/orders/{order_id}

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789

Response 200:
{
  "id": "order_NXhj67fGH2jk9mPq",
  "merchant_id": "550e8400-e29b-41d4-a716-446655440000",
  "amount": 50000,
  "currency": "INR",
  "receipt": "receipt_123",
  "notes": {},
  "status": "created",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}

Error Response 404:
{
  "error": {
    "code": "NOT_FOUND_ERROR",
    "description": "Order not found"
  }
}
4. Create Payment Endpoint
POST /api/v1/payments

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789
Content-Type: application/json

Request Body (UPI):
{
  "order_id": "order_NXhj67fGH2jk9mPq",
  "method": "upi",
  "vpa": "user@paytm"
}

Request Body (Card):
{
  "order_id": "order_NXhj67fGH2jk9mPq",
  "method": "card",
  "card": {
    "number": "4111111111111111",
    "expiry_month": "12",
    "expiry_year": "2025",
    "cvv": "123",
    "holder_name": "John Doe"
  }
}

Response 201 (UPI):
{
  "id": "pay_H8sK3jD9s2L1pQr",
  "order_id": "order_NXhj67fGH2jk9mPq",
  "amount": 50000,
  "currency": "INR",
  "method": "upi",
  "vpa": "user@paytm",
  "status": "processing",
  "created_at": "2024-01-15T10:31:00Z"
}

Response 201 (Card):
{
  "id": "pay_H8sK3jD9s2L1pQr",
  "order_id": "order_NXhj67fGH2jk9mPq",
  "amount": 50000,
  "currency": "INR",
  "method": "card",
  "card_network": "visa",
  "card_last4": "1111",
  "status": "processing",
  "created_at": "2024-01-15T10:31:00Z"
}
Implementation requirements:

Create an endpoint handler for POST /api/v1/payments that requires authentication

Extract and validate API credentials from request headers (same as order creation endpoint)

Verify order exists and belongs to the authenticated merchant:

Look up order by order_id from request body
Ensure order.merchant_id matches the authenticated merchant
If order not found or doesn't belong to merchant, return 404 or 400 error
Validate payment method specific fields based on method in request body:

For UPI payments (method: "upi"):

Validate vpa field is present and matches VPA format (see VPA validation below)
If invalid, return 400 with appropriate error message
For Card payments (method: "card"):

Validate card object contains: number, expiry_month, expiry_year, cvv, holder_name
Validate card number using Luhn algorithm (see Card validation below)
Detect card network from card number (see Network detection below)
Validate expiry date is in the future (see Expiry validation below)
Extract and store only last 4 digits of card number (never store full card number or CVV)
If any validation fails, return 400 with appropriate error message
Generate payment ID:

Format: "pay_" followed by exactly 16 alphanumeric characters
Must be unique (check for collisions and regenerate if needed)
Create payment record in database:

Set status to "processing" immediately upon creation (payment never goes through "created" state)
Store payment method, amount (from order), currency, and method-specific fields
For cards: store card_network and card_last4 only
Set timestamps (created_at, updated_at)
Process payment synchronously:

Add a delay of 5-10 seconds (random within this range) to simulate bank processing
Determine success/failure randomly:
UPI: 90% success rate (90% chance of success, 10% chance of failure)
Card: 95% success rate (95% chance of success, 5% chance of failure)
Update payment status in database:
If successful: set status to "success"
If failed: set status to "failed" and populate error_code and error_description fields
Update updated_at timestamp
Return response:

HTTP status code 201
JSON body containing payment details including id, order_id, amount, method, status, and method-specific fields
For cards: include card_network and card_last4
For UPI: include vpa
Test Mode for Evaluation (Required): Your implementation must support test mode via environment variables to enable deterministic testing:

TEST_MODE=true - Enables deterministic payment outcomes
TEST_PAYMENT_SUCCESS=true/false - Forces payment success/failure (overrides random logic when TEST_MODE=true)
TEST_PROCESSING_DELAY=<milliseconds> - Sets exact processing delay in milliseconds (overrides random 5-10s range when TEST_MODE=true)
When TEST_MODE=true:

Payment success/failure should be deterministic based on TEST_PAYMENT_SUCCESS (default: true if not set)
Processing delays should use TEST_PROCESSING_DELAY value instead of random range (default: 1000ms if not set)
This allows automated evaluation to have predictable outcomes
Note: This test mode is required for accurate automated evaluation. Your production code should still use random logic when TEST_MODE is not enabled.

Validation logic you must implement:

VPA Validation:

Implement a function to validate Virtual Payment Address (VPA) format
VPA must match the pattern: ^[a-zA-Z0-9._-]+@[a-zA-Z0-9]+$
Before @: One or more alphanumeric characters, dots, underscores, or hyphens
After @: One or more alphanumeric characters (bank/provider identifier)
Valid examples: user@paytm, john.doe@okhdfcbank, user_123@phonepe
Invalid examples: user @paytm (space not allowed), @paytm (missing username), user@@bank (double @), user@ (missing provider)
Card Number Validation (Luhn Algorithm):

Implement a function to validate card numbers using the Luhn algorithm:
Remove all spaces and dashes from the card number
Verify the cleaned number contains only digits and has length between 13 and 19 characters
Apply Luhn algorithm:
Start from the rightmost digit
Moving left, double every second digit (2nd from right, 4th from right, etc.)
If any doubled digit is greater than 9, subtract 9 from it
Sum all digits (both doubled and unchanged)
The card number is valid if the sum modulo 10 equals 0
Return true if valid, false otherwise
Card Network Detection:

Implement a function to detect the card network from the card number
First, remove all spaces and dashes from the card number
Check the first digits to determine network:
Visa: Card number starts with 4
Mastercard: Card number starts with 51, 52, 53, 54, or 55 (two digits: 51-55)
Amex: Card number starts with 34 or 37 (two digits)
RuPay: Card number starts with 60, 65, or any number from 81 to 89 (two digits: 81-89)
Return one of: "visa", "mastercard", "amex", "rupay", or "unknown" if no match
Expiry Validation:

Implement a function to validate card expiry date
Parse the month value: must be an integer between 1 and 12
Parse the year value: accept both formats:
2-digit format (e.g., "25"): Treat as 20XX, so "25" = 2025
4-digit format (e.g., "2025"): Use as-is
Compare the expiry date (month/year combination) with the current date
The expiry date must be in the future or current month (expiry >= current month/year)
Return true if valid, false otherwise
Payment Processing Flow:

Validate all inputs
Create payment record with status processing immediately (payment never goes through created state)
Add 5-10 second delay (simulate bank processing)
Randomly determine success/failure (90% for UPI, 95% for cards)
Update payment status to success or failed
If failed, populate error_code and error_description
Note: The payment status flow is: processing → success/failed. The created state is skipped - payments are created directly with processing status.

5. Get Payment Endpoint
GET /api/v1/payments/{payment_id}

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789

Response 200:
{
  "id": "pay_H8sK3jD9s2L1pQr",
  "order_id": "order_NXhj67fGH2jk9mPq",
  "amount": 50000,
  "currency": "INR",
  "method": "upi",
  "vpa": "user@paytm",
  "status": "success",
  "created_at": "2024-01-15T10:31:00Z",
  "updated_at": "2024-01-15T10:31:10Z"
}
6. Test Endpoints (Required for Evaluation)
These endpoints are required for automated evaluation and help verify system state:

GET /api/v1/test/merchant

Returns test merchant details if seeded correctly
No authentication required (test endpoint)
Response 200:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "test@example.com",
  "api_key": "key_test_abc123",
  "seeded": true
}
Response 404 if test merchant doesn't exist
Note: These test endpoints are required for automated evaluation. They provide visibility into system state without requiring direct database access.

Frontend Requirements
Dashboard Application (Port 3000)
Required pages with exact data-test-id attributes:

1. Login Page (/login):

<form data-test-id="login-form">
  <input 
    data-test-id="email-input" 
    type="email" 
    placeholder="Email"
  />
  <input 
    data-test-id="password-input" 
    type="password" 
    placeholder="Password"
  />
  <button data-test-id="login-button">Login</button>
</form>
For this deliverable, you can use the test merchant credentials directly (no registration needed).

Login Credentials: Use these exact credentials to log into the dashboard:

Email: test@example.com
Password: Any password (not validated for Deliverable 1 - you can implement simple email-based authentication or use API key/secret)
The dashboard should display the merchant's API credentials after login.

2. Dashboard Home (/dashboard):

<div data-test-id="dashboard">
  <div data-test-id="api-credentials">
    <div>
      <label>API Key</label>
      <span data-test-id="api-key">key_test_abc123</span>
    </div>
    <div>
      <label>API Secret</label>
      <span data-test-id="api-secret">secret_test_xyz789</span>
    </div>
  </div>
  
  <div data-test-id="stats-container">
    <div data-test-id="total-transactions">100</div>
    <div data-test-id="total-amount">₹5,00,000</div>
    <div data-test-id="success-rate">95%</div>
  </div>
</div>
Note: The example values shown above (100, ₹5,00,000, 95%) are placeholders. Your implementation should:

Calculate total-transactions from the actual count of payments in the database
Calculate total-amount from the sum of all successful payment amounts
Calculate success-rate as (successful payments / total payments) × 100
Display real-time data from your database, not hardcoded values
3. Transactions Page (/dashboard/transactions):

<table data-test-id="transactions-table">
  <thead>
    <tr>
      <th>Payment ID</th>
      <th>Order ID</th>
      <th>Amount</th>
      <th>Method</th>
      <th>Status</th>
      <th>Created</th>
    </tr>
  </thead>
  <tbody>
    <tr data-test-id="transaction-row" data-payment-id="pay_123">
      <td data-test-id="payment-id">pay_123</td>
      <td data-test-id="order-id">order_456</td>
      <td data-test-id="amount">50000</td>
      <td data-test-id="method">upi</td>
      <td data-test-id="status">success</td>
      <td data-test-id="created-at">2024-01-15 10:31:00</td>
    </tr>
  </tbody>
</table>
Checkout Page (Port 3001)
Checkout Flow (/checkout?order_id=xxx):

The checkout page must:

Accept order_id as query parameter
Fetch order details from API
Display payment method selection
Show payment form based on selected method
Process payment and show result
Required HTML structure with data-test-id:

<div data-test-id="checkout-container">
  <!-- Order Summary -->
  <div data-test-id="order-summary">
    <h2>Complete Payment</h2>
    <div>
      <span>Amount: </span>
      <span data-test-id="order-amount">₹500.00</span>
    </div>
    <div>
      <span>Order ID: </span>
      <span data-test-id="order-id">order_123</span>
    </div>
  </div>
  
  <!-- Payment Method Selection -->
  <div data-test-id="payment-methods">
    <button 
      data-test-id="method-upi" 
      data-method="upi"
      onclick="showUPIForm()"
    >
      UPI
    </button>
    <button 
      data-test-id="method-card" 
      data-method="card"
      onclick="showCardForm()"
    >
      Card
    </button>
  </div>
  
  <!-- UPI Payment Form -->
  <form data-test-id="upi-form" style="display:none">
    <input 
      data-test-id="vpa-input" 
      placeholder="username@bank"
      type="text"
    />
    <button data-test-id="pay-button" type="submit">
      Pay ₹500
    </button>
  </form>
  
  <!-- Card Payment Form -->
  <form data-test-id="card-form" style="display:none">
    <input 
      data-test-id="card-number-input" 
      placeholder="Card Number"
      type="text"
    />
    <input 
      data-test-id="expiry-input" 
      placeholder="MM/YY"
      type="text"
    />
    <input 
      data-test-id="cvv-input" 
      placeholder="CVV"
      type="text"
    />
    <input 
      data-test-id="cardholder-name-input" 
      placeholder="Name on Card"
      type="text"
    />
    <button data-test-id="pay-button" type="submit">
      Pay ₹500
    </button>
  </form>
  
  <!-- Processing State -->
  <div data-test-id="processing-state" style="display:none">
    <div class="spinner"></div>
    <span data-test-id="processing-message">
      Processing payment...
    </span>
  </div>
  
  <!-- Success State -->
  <div data-test-id="success-state" style="display:none">
    <h2>Payment Successful!</h2>
    <div>
      <span>Payment ID: </span>
      <span data-test-id="payment-id">pay_123</span>
    </div>
    <span data-test-id="success-message">
      Your payment has been processed successfully
    </span>
  </div>
  
  <!-- Error State -->
  <div data-test-id="error-state" style="display:none">
    <h2>Payment Failed</h2>
    <span data-test-id="error-message">
      Payment could not be processed
    </span>
    <button data-test-id="retry-button">Try Again</button>
  </div>
</div>
Checkout page behavior:

On page load, fetch order details using order_id from URL
Display order amount and details
When user selects payment method, show appropriate form
On form submit, call /api/v1/payments endpoint
Show processing state during payment
Poll /api/v1/payments/{payment_id} every 2 seconds to check status
When status changes to success or failed, show appropriate state
Checkout Page API Authentication: The checkout page needs to make unauthenticated API calls. Implement one of these approaches:

Public Endpoints (Recommended): Create public endpoints for checkout flow:

GET /api/v1/orders/{order_id}/public - Returns order details (no auth required, only basic info: id, amount, currency, status)
POST /api/v1/payments/public - Creates payment from checkout page (no auth required, but validate order_id belongs to a valid merchant)
Alternative: Make the existing endpoints accept optional authentication - if no auth headers are provided, allow access when order_id is validated to belong to a valid merchant.

The checkout page should use these public endpoints instead of the authenticated merchant endpoints.

Environment Configuration
Create .env.example:

DATABASE_URL=postgresql://gateway_user:gateway_pass@postgres:5432/payment_gateway
PORT=8000

# Test merchant credentials (pre-seeded)
TEST_MERCHANT_EMAIL=test@example.com
TEST_API_KEY=key_test_abc123
TEST_API_SECRET=secret_test_xyz789

# Payment simulation config
UPI_SUCCESS_RATE=0.90
CARD_SUCCESS_RATE=0.95
PROCESSING_DELAY_MIN=5000
PROCESSING_DELAY_MAX=10000

# Test mode for evaluation (required)
TEST_MODE=false
TEST_PAYMENT_SUCCESS=true
TEST_PROCESSING_DELAY=1000

# Webhook retry test mode (Deliverable 2, required)
WEBHOOK_RETRY_INTERVALS_TEST=false
Common Mistakes
Incorrect ID format: Order IDs must start with order_ and payment IDs with pay_, followed by exactly 16 alphanumeric characters. Using UUIDs or other formats will fail automated tests.

Missing health check endpoint: The /health endpoint must return exactly the specified JSON structure. This is the first endpoint tested and many submissions fail here.

Incorrect HTTP status codes: Use 201 for resource creation (orders, payments), 200 for successful GET requests, 400 for validation errors, 401 for authentication failures, and 404 for not found errors.

Not implementing authentication: Every API endpoint except /health must validate X-Api-Key and X-Api-Secret headers. Many students forget this and APIs remain open.

Incorrect payment status flow: Payments must go through these states correctly: processing → success/failed. Payments are created directly with processing status (skip the created state). Never skip the processing state.

Missing data-test-id attributes: Frontend automated tests rely on these exact attributes. Missing or misnamed attributes cause test failures even if functionality works.

Not seeding test merchant: Your application must automatically create the test merchant with exact credentials specified. Evaluators won't manually create merchants.

Improper card validation: Simply checking length isn't enough—implement the full Luhn algorithm. Also ensure you're storing only last 4 digits of cards, never full numbers.

Hardcoded ports in code: Use environment variables for all ports and connection strings so the application works correctly in Docker.

Docker services not waiting for dependencies: Use health checks and depends_on with conditions to ensure services start in correct order. Many submissions fail because API starts before database is ready.

FAQs
Q: Can I use a different tech stack instead of Java Spring Boot?
A: Yes! You can use Node.js (Express/NestJS), Python (Django/FastAPI), Go, or any other stack. The specifications (API endpoints, response formats, data-test-ids) must remain exactly the same regardless of technology choice.

Q: Do I need to implement actual payment processing with banks?
A: No. This is a simulation. Your payment processing should add a 5-10 second delay, then randomly return success/failure based on configured success rates (90% for UPI, 95% for cards). No real banking integrations are needed.

Q: How should I handle the payment processing delay?
A: For Deliverable 1, implement synchronous processing with Thread.sleep() or equivalent. The API should wait 5-10 seconds before returning the final payment status. (Deliverable 2 will introduce asynchronous job processing.)

Q: What should I do with card CVV and full card numbers?
A: Never store CVV or full card numbers in your database. Validate the card number and CVV during payment creation, but only store the card network (visa/mastercard) and last 4 digits in the database.

Q: Can I add additional API endpoints beyond what's specified?
A: Yes, you can add extra endpoints for enhanced functionality, but all specified endpoints with exact request/response formats must be implemented first as they are part of automated evaluation.

Q: How will the data-test-id attributes be used in evaluation?
A: Automated Selenium tests will locate elements using these attributes to verify your frontend functionality. If attributes are missing or incorrect, tests will fail even if the UI looks perfect.

Q: Should I implement user registration for merchants?
A: Not required for Deliverable 1. Just ensure the test merchant is auto-seeded on application startup with the exact credentials provided. You can add registration as an extra feature if you want.

Q: What should the checkout page URL format be?
A: The checkout page must be accessible at http://localhost:3001/checkout?order_id={order_id}. The order_id query parameter is mandatory.

Q: How do I test if my implementation is correct before submission?
A: Test using the provided test credentials to create orders via API (using Postman/curl), then access the checkout page with that order_id. Verify the payment flow works end-to-end and all data-test-id attributes are present in your HTML.

Q: What happens if docker-compose up fails?
A: This will result in zero score as automated evaluation cannot proceed. Ensure all Dockerfiles are correct, health checks are implemented, and services start successfully with proper dependency ordering before submitting.



updated project info 


Partnr Logo
Dashboard
Skill Graph
Profile
GPP

Praveen Adapa
Build Production-Ready Payment Gateway with Async Processing and Webhooks
Mandatory Task

Back
Domain
Backend Development
Skills
API Development
Communication
Database Management
Deep Learning
Docker Compose Configuration
EDA
Exponential Backoff Implementation
HMAC Signature Generation
Management
Product
Public Relations
SDK Development
Solution Architecture
System Reliability
Webhook Implementation
Difficulty
Advanced
Tools
Bull
Celery
Docker
Express.Js
FastAPI
Go
Java
Node.Js
PostgreSQL
Python
React
Redis
RQ
Spring Boot
Webpack
Industries
Fintech
Submission Received
Your submission has been received and is pending review. You can still update your submission till the effective deadline.

Submitted on 17 Jan 2026, 04:06 pm

Deadline: 21 Jan 2026, 04:59 pm

Overview
Instructions
Resources
Submit
Description
Objective
Building on your payment gateway core, you will now transform it into a production-ready system by implementing asynchronous job processing, webhook delivery with retry mechanisms, embeddable JavaScript SDK, and refund management. This deliverable focuses on architectural patterns that enable scalability and reliability in real-world payment systems.

You'll learn to use message queues (Redis + Bull/Celery) for background job processing, implement event-driven architecture through webhooks with HMAC signature verification, build cross-origin embeddable widgets, handle idempotent API operations, and manage complex retry logic with exponential backoff. These are advanced patterns used by companies like Stripe, Razorpay, and PayPal. Completing this deliverable demonstrates your ability to build resilient, scalable systems that can handle real production workloads—a skill that distinguishes senior engineers from junior developers.

Core Requirements
Asynchronous payment processing using Redis-based job queues with worker services processing payments in the background
Webhook system that delivers payment events to merchant URLs with HMAC signature verification and automatic retry logic (5 attempts with exponential backoff)
Embeddable JavaScript SDK that merchants can integrate on their websites to accept payments via modal/iframe without redirects
Refund API with full and partial refund support, processed asynchronously through job workers
Idempotency keys on payment creation to prevent duplicate charges on network retries
Enhanced dashboard with webhook configuration, delivery logs, manual retry functionality, and integration documentation
Implementation Details
Updated Docker Compose
Add Redis and worker services to your existing docker-compose.yml:

version: '3.8'

services:
  postgres:
    # ... (keep existing configuration)

  redis:
    image: redis:7-alpine
    container_name: redis_gateway
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  api:
    # ... (keep existing configuration)
    environment:
      # ... (existing env vars)
      REDIS_URL: redis://redis:6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.worker
    container_name: gateway_worker
    environment:
      DATABASE_URL: postgresql://gateway_user:gateway_pass@postgres:5432/payment_gateway
      REDIS_URL: redis://redis:6379
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      api:
        condition: service_healthy

  dashboard:
    # ... (keep existing configuration)

  checkout:
    # ... (keep existing configuration)
Updated Database Schema
Add these additional tables and modifications to your existing database schema:

Refunds Table:

id: Refund identifier (string, up to 64 characters), primary key, format: "rfnd_" + 16 alphanumeric characters
payment_id: Reference to payments table (string, up to 64 characters), required, foreign key to payments(id)
merchant_id: Reference to merchants table (UUID), required, foreign key to merchants(id)
amount: Refund amount in smallest currency unit (integer), required
reason: Refund reason/description (text), optional
status: Refund status (string, up to 20 characters), defaults to 'pending' (values: 'pending', 'processed')
created_at: Creation timestamp, auto-set to current time
processed_at: Processing completion timestamp, optional, set when status changes to 'processed'
Webhook Logs Table:

id: Unique identifier (UUID format), primary key, auto-generated
merchant_id: Reference to merchants table (UUID), required, foreign key to merchants(id)
event: Event type identifier (string, up to 50 characters), required (e.g., "payment.success", "refund.processed")
payload: Event payload data (JSON object), required
status: Delivery status (string, up to 20 characters), defaults to 'pending' (values: 'pending', 'success', 'failed')
attempts: Number of delivery attempts made (integer), defaults to 0
last_attempt_at: Timestamp of last delivery attempt, optional
next_retry_at: Timestamp for next retry attempt, optional, used for scheduling retries
response_code: HTTP response code from merchant's webhook endpoint (integer), optional
response_body: Response body from merchant's webhook endpoint (text), optional
created_at: Creation timestamp, auto-set to current time
Idempotency Keys Table:

key: Idempotency key string (string, up to 255 characters), primary key, scoped with merchant_id
merchant_id: Reference to merchants table (UUID), required, foreign key to merchants(id)
response: Cached API response (JSON object), required, stores the complete response for the request
created_at: Creation timestamp, auto-set to current time
expires_at: Expiration timestamp, required, set to created_at + 24 hours
Merchants Table Modification:

Add new column webhook_secret: Webhook secret for HMAC signature generation (string, up to 64 characters), optional
Update test merchant record: Set webhook_secret to 'whsec_test_abc123' for the merchant with email 'test@example.com'
Note: The webhook_secret column is only added in Deliverable 2. For Deliverable 1, the merchants table does not need this column. When implementing Deliverable 2, add this column to your existing merchants table.

Required Indexes:

Index on refunds.payment_id for efficient payment refund queries
Index on webhook_logs.merchant_id for efficient merchant webhook queries
Index on webhook_logs.status for efficient status-based queries
Index on webhook_logs.next_retry_at where status is 'pending' for efficient retry scheduling queries
Job Queue System
Worker Service Structure:

backend/
├── Dockerfile.worker
└── src/
    └── main/java/com/gateway/
        ├── workers/
        │   ├── PaymentWorker.java
        │   ├── WebhookWorker.java
        │   └── RefundWorker.java
        └── jobs/
            ├── ProcessPaymentJob.java
            ├── DeliverWebhookJob.java
            └── ProcessRefundJob.java
Job Types to Implement:

1. Process Payment Job:

Create a background job worker that processes payment requests asynchronously
Job receives payment ID as input parameter
Implementation steps:
Fetch payment record from database using the payment ID
Simulate payment processing delay: wait 5-10 seconds (random within this range)
Test Mode: When TEST_MODE=true, use TEST_PROCESSING_DELAY value instead of random range (default: 1000ms if not set)
Determine payment outcome randomly based on success rate:
UPI payments: 90% success rate (90% chance of success, 10% chance of failure)
Card payments: 95% success rate (95% chance of success, 5% chance of failure)
Test Mode: When TEST_MODE=true, use TEST_PAYMENT_SUCCESS to determine outcome (overrides random logic, default: true if not set)
Update payment status in database:
If successful: set status to 'success'
If failed: set status to 'failed' and populate error_code and error_description fields
Enqueue a webhook delivery job for the appropriate event:
If successful: enqueue webhook for 'payment.success' event
If failed: enqueue webhook for 'payment.failed' event
Include payment data in webhook payload
Note: Test mode support is required for automated evaluation to ensure deterministic job processing.

2. Deliver Webhook Job:

Create a background job worker that delivers webhook events to merchant endpoints
Job receives merchant ID, event type, and payload data as input parameters
Implementation steps:
Fetch merchant details from database using merchant ID:
Retrieve webhook_url (must be configured, skip if NULL)
Retrieve webhook_secret for signature generation
Generate HMAC-SHA256 signature:
Use merchant's webhook_secret as the key
Use the JSON string representation of the payload (no whitespace changes)
Generate hex-encoded signature
Send HTTP POST request to merchant's webhook_url:
Header: X-Webhook-Signature: <generated_signature>
Header: Content-Type: application/json
Body: JSON payload
Timeout: 5 seconds
Log webhook attempt in webhook_logs table:
Record attempt number (increment from previous attempts)
Record response code and response body (if available)
Record last_attempt_at timestamp
If successful (HTTP 200-299): set status to 'success'
If failed: set status to 'pending' and increment attempts
If delivery failed and attempts < 5:
Calculate next_retry_at timestamp based on retry schedule (see Webhook Retry Logic below)
Keep status as 'pending' for future retry
If delivery failed and attempts >= 5:
Set status to 'failed' permanently
Stop retrying
3. Process Refund Job:

Create a background job worker that processes refund requests asynchronously
Job receives refund ID as input parameter
Implementation steps:
Fetch refund record from database using the refund ID
Verify payment is in refundable state:
Payment status must be 'success'
Verify total refunded amount (sum of all refunds for this payment) does not exceed payment amount
Simulate refund processing delay: wait 3-5 seconds (random within this range)
Update refund status in database:
Set status to 'processed'
Set processed_at timestamp to current time
If refund amount equals payment amount (full refund):
Optionally update payment record to reflect full refund status
Enqueue webhook delivery job for 'refund.processed' event:
Include refund data in webhook payload
Webhook Retry Logic:

Attempt 1: Immediate
Attempt 2: After 1 minute
Attempt 3: After 5 minutes
Attempt 4: After 30 minutes
Attempt 5: After 2 hours

After 5 failed attempts, mark webhook as permanently failed
Test Mode for Webhook Retries (Required): Your implementation must support shorter retry intervals for testing via environment variable:

WEBHOOK_RETRY_INTERVALS_TEST=true - Uses test intervals instead of production intervals
When WEBHOOK_RETRY_INTERVALS_TEST=true, use these intervals:

Attempt 1: 0 seconds (immediate)
Attempt 2: 5 seconds
Attempt 3: 10 seconds
Attempt 4: 15 seconds
Attempt 5: 20 seconds
This allows complete retry cycle testing in under 1 minute instead of hours. This test mode is required for automated evaluation.

Note: Production code should use the standard intervals (1 min, 5 min, 30 min, 2 hr) when WEBHOOK_RETRY_INTERVALS_TEST is not enabled.

Updated API Endpoints
Modified Create Payment Endpoint
POST /api/v1/payments

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789
Idempotency-Key: unique_request_id_123 (optional)
Content-Type: application/json

Request Body:
{
  "order_id": "order_NXhj67fGH2jk9mPq",
  "method": "upi",
  "vpa": "user@paytm"
}

Response 201:
{
  "id": "pay_H8sK3jD9s2L1pQr",
  "order_id": "order_NXhj67fGH2jk9mPq",
  "amount": 50000,
  "currency": "INR",
  "method": "upi",
  "vpa": "user@paytm",
  "status": "pending",
  "created_at": "2024-01-15T10:31:00Z"
}
Updated implementation requirements (for Deliverable 2):

Create an endpoint handler for POST /api/v1/payments that requires authentication
Extract and validate API credentials from request headers (same as Deliverable 1)
Handle optional Idempotency-Key header:
If idempotency key is provided:
Check if a record exists in idempotency_keys table with:
key matching the provided idempotency key
merchant_id matching the authenticated merchant
If found and not expired (expires_at > current time):
Return the cached response from the idempotency_keys record
Do not process the request again
If found but expired:
Delete the expired record
Treat as a new request and continue processing
If not found:
Continue with normal processing
Validate payment details (same validation as Deliverable 1)
Create payment record in database:
Set status to 'pending' (changed from 'processing' in Deliverable 1)
Store all payment fields
Set timestamps
Enqueue ProcessPaymentJob with payment ID:
Add job to background job queue (Redis-based)
Do not wait for job completion
Payment processing happens asynchronously
If idempotency key was provided:
Store the API response in idempotency_keys table
Scope the key to merchant_id + idempotency_key combination
Set expires_at to created_at + 24 hours
Return response immediately:
HTTP status code 201
JSON body with payment details (status will be 'pending')
Do not wait for payment processing to complete
New: Capture Payment Endpoint
POST /api/v1/payments/{payment_id}/capture

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789
Content-Type: application/json

Request Body:
{
  "amount": 50000
}

Response 200:
{
  "id": "pay_H8sK3jD9s2L1pQr",
  "order_id": "order_NXhj67fGH2jk9mPq",
  "amount": 50000,
  "currency": "INR",
  "method": "upi",
  "status": "success",
  "captured": true,
  "created_at": "2024-01-15T10:31:00Z",
  "updated_at": "2024-01-15T10:32:00Z"
}

Error Response 400:
{
  "error": {
    "code": "BAD_REQUEST_ERROR",
    "description": "Payment not in capturable state"
  }
}
Implementation notes: Update captured field to true in payments table.

New: Create Refund Endpoint
POST /api/v1/payments/{payment_id}/refunds

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789
Content-Type: application/json

Request Body:
{
  "amount": 50000,
  "reason": "Customer requested refund"
}

Response 201:
{
  "id": "rfnd_K9pL2mN4oQ5r",
  "payment_id": "pay_H8sK3jD9s2L1pQr",
  "amount": 50000,
  "reason": "Customer requested refund",
  "status": "pending",
  "created_at": "2024-01-15T10:33:00Z"
}

Error Response 400:
{
  "error": {
    "code": "BAD_REQUEST_ERROR",
    "description": "Refund amount exceeds available amount"
  }
}
Implementation requirements:

Create an endpoint handler for POST /api/v1/payments/{payment_id}/refunds that requires authentication
Extract and validate API credentials from request headers (same as other endpoints)
Extract payment ID from URL path parameter
Validate credentials and fetch payment:
Look up payment by payment_id
Ensure payment.merchant_id matches the authenticated merchant
If payment not found or doesn't belong to merchant, return 404 or 400 error
Verify payment is refundable:
Payment status must be 'success' (only successful payments can be refunded)
If payment status is not 'success', return 400 with error code "BAD_REQUEST_ERROR"
Calculate total already refunded:
Query all refunds for this payment_id
Sum the amount field of all refunds with status 'processed' or 'pending'
This represents the total amount already refunded or in process
Validate refund amount:
Request body must contain amount (integer, required) and reason (string, optional)
Verify: requested_amount <= (payment.amount - total_refunded_amount)
If validation fails, return 400 with error code "BAD_REQUEST_ERROR" and description "Refund amount exceeds available amount"
Generate refund ID:
Format: "rfnd_" followed by exactly 16 alphanumeric characters
Must be unique (check for collisions and regenerate if needed)
Create refund record in database:
Set status to 'pending'
Store payment_id, merchant_id, amount, reason
Set created_at timestamp
Enqueue ProcessRefundJob:
Add job to background job queue with refund ID
Do not wait for job completion
Refund processing happens asynchronously
Return response:
HTTP status code 201
JSON body containing refund details including id, payment_id, amount, reason, status, and created_at
New: Get Refund Endpoint
GET /api/v1/refunds/{refund_id}

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789

Response 200:
{
  "id": "rfnd_K9pL2mN4oQ5r",
  "payment_id": "pay_H8sK3jD9s2L1pQr",
  "amount": 50000,
  "reason": "Customer requested refund",
  "status": "processed",
  "created_at": "2024-01-15T10:33:00Z",
  "processed_at": "2024-01-15T10:33:05Z"
}
New: List Webhook Logs Endpoint
GET /api/v1/webhooks?limit=10&offset=0

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789

Response 200:
{
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "event": "payment.success",
      "status": "success",
      "attempts": 1,
      "created_at": "2024-01-15T10:31:10Z",
      "last_attempt_at": "2024-01-15T10:31:11Z",
      "response_code": 200
    }
  ],
  "total": 1,
  "limit": 10,
  "offset": 0
}
New: Retry Webhook Endpoint
POST /api/v1/webhooks/{webhook_id}/retry

Headers:
X-Api-Key: key_test_abc123
X-Api-Secret: secret_test_xyz789

Response 200:
{
  "id": "550e8400-e29b-41d4-a716-446655440001",
  "status": "pending",
  "message": "Webhook retry scheduled"
}
Implementation: Reset attempts to 0, set status to 'pending', enqueue DeliverWebhookJob.

New: Job Queue Status Endpoint (Required for Evaluation)
GET /api/v1/test/jobs/status

No authentication required (test endpoint)

Response 200:
{
  "pending": 5,
  "processing": 2,
  "completed": 100,
  "failed": 0,
  "worker_status": "running"
}
Implementation requirements:

Create an endpoint handler for GET /api/v1/test/jobs/status that does not require authentication
Query the job queue (Redis) to get statistics:
pending: Count of jobs waiting to be processed
processing: Count of jobs currently being processed
completed: Count of successfully completed jobs (optional, can be approximate)
failed: Count of failed jobs (optional, can be approximate)
worker_status: String indicating if worker is running ("running" or "stopped")
Return HTTP status code 200
Note: This test endpoint is required for automated evaluation. It provides visibility into job queue state without requiring direct Redis access.

Webhook Specification
Events to emit:

payment.created - When payment record is created
payment.pending - When payment enters pending state
payment.success - When payment succeeds
payment.failed - When payment fails
refund.created - When refund is initiated
refund.processed - When refund completes
Webhook Payload Format:

{
  "event": "payment.success",
  "timestamp": 1705315870,
  "data": {
    "payment": {
      "id": "pay_H8sK3jD9s2L1pQr",
      "order_id": "order_NXhj67fGH2jk9mPq",
      "amount": 50000,
      "currency": "INR",
      "method": "upi",
      "vpa": "user@paytm",
      "status": "success",
      "created_at": "2024-01-15T10:31:00Z"
    }
  }
}
Signature Generation:

Implement a function to generate webhook signatures for secure event delivery
Algorithm: Use HMAC-SHA256 (Hash-based Message Authentication Code with SHA-256)
Input parameters:
payload: The webhook payload as a JSON string (must be the exact string sent in HTTP body, no whitespace changes)
webhookSecret: The merchant's webhook_secret from the database
Process:
Use the merchant's webhook_secret as the HMAC key
Use the JSON string representation of the payload as the data to sign
Important: The JSON string must match exactly what will be sent in the HTTP request body (no pretty-printing, no whitespace changes)
Generate HMAC-SHA256 hash of the payload using the secret
Encode the hash as a hexadecimal string (lowercase or uppercase, both acceptable)
Return: The hex-encoded signature string
Example: For payload {"event":"payment.success","data":{...}} and secret whsec_test_abc123, generate signature like a1b2c3d4e5f6... (64 hex characters for SHA-256)
Webhook HTTP Request:

POST https://merchant-website.com/webhook

Headers:
Content-Type: application/json
X-Webhook-Signature: <generated_signature>

Body:
<JSON payload>
Embeddable SDK
Create a JavaScript SDK that merchants can include on their websites:

File structure:

checkout-widget/
├── src/
│   ├── sdk/
│   │   ├── PaymentGateway.js
│   │   ├── modal.js
│   │   └── styles.css
│   └── iframe-content/
│       └── CheckoutForm.jsx
├── webpack.config.js
└── dist/
    └── checkout.js (bundled output)
SDK API:

// File: PaymentGateway.js
class PaymentGateway {
  constructor(options) {
    // options: {
    //   key: 'key_test_abc123',
    //   orderId: 'order_xyz',
    //   onSuccess: function(response) { },
    //   onFailure: function(error) { },
    //   onClose: function() { }
    // }
    //
    // Implementation:
    // 1. Validate required options
    // 2. Store configuration
    // 3. Prepare iframe modal
  }
  
  open() {
    // 1. Create modal overlay
    // 2. Create iframe with src pointing to checkout page
    // 3. Set iframe attributes with data-test-id="payment-iframe"
    // 4. Append modal to document body
    // 5. Set up postMessage listener for iframe communication
    // 6. Show modal
  }
  
  close() {
    // 1. Remove modal from DOM
    // 2. Call onClose callback if provided
  }
}

// Expose globally
window.PaymentGateway = PaymentGateway;
Usage by merchants:

<script src="https://cdn.yourgateway.com/checkout.js"></script>
<button id="pay-button">Pay Now</button>

<script>
document.getElementById('pay-button').addEventListener('click', function() {
  const checkout = new PaymentGateway({
    key: 'key_test_abc123',
    orderId: 'order_xyz',
    onSuccess: function(response) {
      console.log('Payment successful:', response.paymentId);
    },
    onFailure: function(error) {
      console.log('Payment failed:', error);
    }
  });
  
  checkout.open();
});
</script>
SDK modal HTML structure (for automated testing):

<div id="payment-gateway-modal" data-test-id="payment-modal">
  <div class="modal-overlay">
    <div class="modal-content">
      <iframe 
        data-test-id="payment-iframe"
        src="http://localhost:3001/checkout?order_id=xxx&embedded=true"
      ></iframe>
      <button 
        data-test-id="close-modal-button" 
        class="close-button"
      >
        ×
      </button>
    </div>
  </div>
</div>
Cross-origin communication:

// In iframe (checkout page)
function sendMessageToParent(type, data) {
  window.parent.postMessage({
    type: type,  // 'payment_success', 'payment_failed', 'close_modal'
    data: data
  }, '*');
}

// In SDK (parent page)
window.addEventListener('message', function(event) {
  if (event.data.type === 'payment_success') {
    this.onSuccess(event.data.data);
    this.close();
  } else if (event.data.type === 'payment_failed') {
    this.onFailure(event.data.data);
  }
});
Enhanced Dashboard Features
New: Webhook Configuration Page (/dashboard/webhooks):

<div data-test-id="webhook-config">
  <h2>Webhook Configuration</h2>
  
  <form data-test-id="webhook-config-form">
    <div>
      <label>Webhook URL</label>
      <input 
        data-test-id="webhook-url-input"
        type="url"
        placeholder="https://yoursite.com/webhook"
      />
    </div>
    
    <div>
      <label>Webhook Secret</label>
      <span data-test-id="webhook-secret">whsec_test_abc123</span>
      <button data-test-id="regenerate-secret-button">
        Regenerate
      </button>
    </div>
    
    <button data-test-id="save-webhook-button" type="submit">
      Save Configuration
    </button>
    
    <button data-test-id="test-webhook-button" type="button">
      Send Test Webhook
    </button>
  </form>
  
  <h3>Webhook Logs</h3>
  <table data-test-id="webhook-logs-table">
    <thead>
      <tr>
        <th>Event</th>
        <th>Status</th>
        <th>Attempts</th>
        <th>Last Attempt</th>
        <th>Response Code</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <tr data-test-id="webhook-log-item" data-webhook-id="log_123">
        <td data-test-id="webhook-event">payment.success</td>
        <td data-test-id="webhook-status">success</td>
        <td data-test-id="webhook-attempts">1</td>
        <td data-test-id="webhook-last-attempt">
          2024-01-15 10:31:11
        </td>
        <td data-test-id="webhook-response-code">200</td>
        <td>
          <button 
            data-test-id="retry-webhook-button"
            data-webhook-id="log_123"
          >
            Retry
          </button>
        </td>
      </tr>
    </tbody>
  </table>
</div>
New: API Documentation Page (/dashboard/docs):

<div data-test-id="api-docs">
  <h2>Integration Guide</h2>
  
  <section data-test-id="section-create-order">
    <h3>1. Create Order</h3>
    <pre data-test-id="code-snippet-create-order">
<code>
curl -X POST http://localhost:8000/api/v1/orders \
  -H "X-Api-Key: key_test_abc123" \
  -H "X-Api-Secret: secret_test_xyz789" \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 50000,
    "currency": "INR",
    "receipt": "receipt_123"
  }'
</code>
    </pre>
  </section>
  
  <section data-test-id="section-sdk-integration">
    <h3>2. SDK Integration</h3>
    <pre data-test-id="code-snippet-sdk">
<code>
&lt;script src="http://localhost:3001/checkout.js"&gt;&lt;/script&gt;
&lt;script&gt;
const checkout = new PaymentGateway({
  key: 'key_test_abc123',
  orderId: 'order_xyz',
  onSuccess: (response) => {
    console.log('Payment ID:', response.paymentId);
  }
});
checkout.open();
&lt;/script&gt;
</code>
    </pre>
  </section>
  
  <section data-test-id="section-webhook-verification">
    <h3>3. Verify Webhook Signature</h3>
    <pre data-test-id="code-snippet-webhook">
<code>
const crypto = require('crypto');

function verifyWebhook(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(JSON.stringify(payload))
    .digest('hex');
  
  return signature === expectedSignature;
}
</code>
    </pre>
  </section>
</div>
Testing Your Implementation
Create a simple merchant test app to verify webhooks work:

// test-merchant/webhook-receiver.js
const express = require('express');
const crypto = require('crypto');

const app = express();
app.use(express.json());

app.post('/webhook', (req, res) => {
  const signature = req.headers['x-webhook-signature'];
  const payload = JSON.stringify(req.body);
  
  // Verify signature
  const expectedSignature = crypto
    .createHmac('sha256', 'whsec_test_abc123')
    .update(payload)
    .digest('hex');
  
  if (signature !== expectedSignature) {
    console.log('❌ Invalid signature');
    return res.status(401).send('Invalid signature');
  }
  
  console.log('✅ Webhook verified:', req.body.event);
  console.log('Payment ID:', req.body.data.payment.id);
  
  res.status(200).send('OK');
});

app.listen(4000, () => {
  console.log('Test merchant webhook running on port 4000');
});
Run this and configure your webhook URL to http://host.docker.internal:4000/webhook (on Mac/Windows) or http://172.17.0.1:4000/webhook (on Linux).

Common Mistakes
Job queue not processing: Ensure worker service is running and connected to Redis. Check that jobs are being enqueued correctly and workers are consuming them. Many students forget to start the worker container.

Webhook signatures don't match: The signature must be generated from the exact JSON string sent in the request body. Don't pretty-print or modify the JSON. Use the same string for both signature generation and HTTP body.

Idempotency keys not working: Keys must be checked before any database operations. Store the complete response (not just payment ID) and return it identically on subsequent requests with the same key.

Exponential backoff incorrect: Retry delays must follow this exact schedule:

Attempt 1: Immediate (0 delay)
Attempt 2: After 1 minute (60 seconds)
Attempt 3: After 5 minutes (300 seconds)
Attempt 4: After 30 minutes (1800 seconds)
Attempt 5: After 2 hours (7200 seconds)
Store the next_retry_at timestamp in the database based on these delays.

SDK not loading in parent page: Ensure your webpack config outputs a UMD bundle that exposes PaymentGateway globally. Check the bundle works by loading it in a plain HTML file.

PostMessage origin restrictions: While '*' origin is acceptable for this project, in production you should validate event.origin. Document this security consideration in your README.

Refund amount validation: Must check total refunded amount across all refunds for a payment, not just individual refund amounts. A payment of ₹500 should not allow two ₹400 refunds.

Webhook retry scheduling: Use database next_retry_at field to schedule retries, don't use in-memory timers. Workers may restart and lose scheduled retries.

Payment status from Deliverable 1: In Deliverable 1, payments are created with status 'processing' and processed synchronously. For Deliverable 2, update your payment creation flow to return status 'pending' instead of 'processing', since processing now happens asynchronously via job workers. The status flow in Deliverable 2 is: pending → (worker processes) → success/failed.

Missing captured field: Add captured BOOLEAN DEFAULT false to payments table. This field tracks whether a successful payment has been captured for settlement.

FAQs
Q: Should webhooks be delivered even if merchant's webhook URL is not set?
A: No. Only create webhook logs and attempt delivery if webhook_url is configured for the merchant. If NULL, skip webhook delivery but still process the payment normally.

Q: How do I test webhook retries without waiting hours?
A: For development, you can use shorter retry intervals (e.g., 10s, 30s, 1m, 2m, 5m). Just ensure the production configuration uses the specified intervals: 1min, 5min, 30min, 2hr.

Q: Can I use a different job queue instead of Bull/Celery?
A: Yes, as long as it's Redis-based. Options include BullMQ (Node.js), RQ (Python), Sidekiq (Ruby), or Asynq (Go). The key requirement is reliable background job processing with retry support.

Q: How should the SDK be served to merchants?
A: Build the SDK into a single checkout.js file using webpack/rollup. Serve it as a static file from your checkout service on port 3001. Merchants can include it via: <script src="http://localhost:3001/checkout.js"></script>

Q: What if a webhook fails after 5 attempts?
A: Mark the webhook log status as failed permanently and stop retrying. Merchants can manually retry from the dashboard if needed using the retry button, which resets attempts to 0.

Q: Should refunds be instant or take time?
A: Simulate a 3-5 second processing delay in the RefundWorker, then update status to processed. This mimics real-world refund processing time.

Q: How do I handle partial refunds correctly?
A: Track all refunds for a payment. Before creating a new refund, sum all existing refunds for that payment and ensure requested_amount + sum(existing_refunds) <= payment.amount. Store each refund as a separate record.

Q: What should the idempotency key expiry time be?
A: 24 hours from creation. After expiry, the same key can be reused. Store expiry as created_at + 24 hours and check if current_time < expires_at before returning cached response.

Q: How do I test the SDK locally without HTTPS?
A: For local development, HTTP is fine. The SDK should work on http://localhost:3001. For production, you'd need HTTPS, but that's not required for this project.

Q: Should the SDK work on mobile browsers?
A: Yes, the modal/iframe should be responsive and work on mobile viewports. Test on Chrome DevTools mobile emulation to ensure it's usable on smaller screens.

Q: What if merchant's webhook endpoint returns 500 error?
A: Treat it as a failed delivery attempt. Log the response code (500), increment attempts, and schedule a retry if attempts < 5. Merchants can see the error in webhook logs.

